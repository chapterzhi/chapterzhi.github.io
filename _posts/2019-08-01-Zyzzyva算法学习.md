---
title: Zyzzyva算法学习
date: 2019-08-01 10:52:30
categories:
- zyzzyva
tags: 
- zyzzyva
---

Zyzzyva算法，在状态机复制中的一个重要的算法，现总结其过程如下。  
Zyzzyva在3f+1个副本replicas之间执行

  > 问题1:为什么一定要3f+1?  
  假设有f个拜占庭节点，由于后面要叙述的安全性问题，要至少要有一个正确节点对两个请求都排过序，之前每个请求在至少 2f + 1 个节点上取得了一致，2f + 1 个节点中除去最多f个可能的拜占庭节点，还有至少 f + 1 个正确节点对于一个请求达到了一致，一共有 3f + 1 个节点，其中 2f + 1 个正确节点，每个请求在至少 f + 1 个正确节点上达成一致，那么就至少有一个正确节点同时参与了两个请求的一致同意。  
  反过来说，假设共有 x 个节点，有 f 个拜占庭节点，每次请求有 n 个节点参与，n > f，n 中最多包含 f 个拜占庭节点，且需要有至少 1 个好节点同时参与两个请求的一致性同意。故需满足以下表达式：  
  2(n - f) > x - f  
  意为两次参与请求一致性同意的好节点个数和大于系统中好节点的个数，那么就说明有至少一个好节点同时参与了两次请求的处理。
  或者可以写为

首先，客户端client想要执行一个请求,所以客户端发送一个 _request_ 给主节点primary。
  
  > 问题2:为什么不直接发送给所有副本?  

主节点将请求发给其他所有副本，副本执行请求并将它们的回复 _responses_ 发给客户端。
  
  > 问题3:为什么不发回给主节点?

这时，一个请求可能在此完成，这里是请求完成的第一个方式，就是如果客户端收到3f+1个一致的回复(包含应用层面的 _reply_ 和 _history_ )。这时客户端认为请求完成。
  
  > 问题4:为什么此时认为请求完成?

第二种完成方式，如果客户端收到2f+1到3f之间的一致的回复，这时客户端将2f+1个回复打包并分发这个 _提交证书 commit certificate_ 给所有副本。
  
  > 问题5:为什么是2f+1个证书?  
    问题6:为什么要发给所有副本?

一旦有2f+1个副本承认收到了提交证书，那么客户端就认为请求完成了。

  > 问题7:为什么这里可以认为请求完成了？

如果有充足数量的副本认为当前的主节点是有错误的(拜占庭节点)，那么会有一个 _视图改变 view change_ 发生，一个新的主节点就会被选出。以上就是zyzzyva的主要过程。  

接着讨论副本的问题。每个副本 _i_ 中保存着一个有序的 _历史 histroy_，历史中包含了该副本所有执行过的请求，副本中还有一个 _max commit certificate_ 的拷贝。

  > 问题8:max commit certificate的作用?

__这个提交证书包含了i存储的历史的最大的前缀。__ 被提交证书覆盖到的历史是 _已提交历史 committed history_ ,这以后的历史是 _推测历史 speculative history_ 。如果n是已提交历史中的最大序列号，我们说一个提交证书具有序列号n。
每次有 CP_INTERVAL 请求时，副本构建一个检查点。每个副本保存有一个 _稳定检查点 stable checkpoint_ ,还可能保存了一个 _实验性检查点 tentative checkpoing_ 和一个对应的 _实验性应用状态快照 tentative application state snapshot_ 。实验性检查点和应用状态成为已提交的的过程和之前的BFT协议很相似，后续再讨论这一点。  
简单来说，当一个正确的副本生成一个实验性检查点，他发送一个标记为 CHECKPOINT 的信息给所有的副本。信息中包含了这个检查点中包含的最高的序列号和一个实验性检查点和应用状态快照的摘要。一个正确的Zyzzyva副本收集了f+1个匹配的被不同副本签名的CHECKPOINT信息后，就会认为这个检查点和对应的应用快照是稳定的。  
为了限制历史的大小，一个副本采用两个方法，(1)缩短已提交检查点之前的历史，(2)从上次已提交检查点之后处理 2\*CP_INTERVAL 个请求后阻塞新请求的处理。
最后，每个副本保存一个 _回复缓存 response cache_，其中包含了最新的有序的请求来自的客户端，和相应的回复到的地方。  
接着，对之前的过程进行详细说明。
### 1. 用户发送请求给主节点
一个客户端c请求一个操作o被复制的服务实行，就发送一个信息<REQUEST, o, t, c><sub>σ<sub>c</sub></sub>给一个客户端认为是主节点的(这个客户端最后一次收到回复的主节点)。  
如果客户端猜错了主节点，重传机制会将请求发送给当前主节点。客户端的时间戳t确保请求只被执行一次。
### 2. 主节点接收请求，分配序列号，将有序请求发送给副本们  
当主节点p从客户端c收到消息m(m = <REQUEST, o, t, c><sub>σ<sub>c</sub></sub>)，主节点p分配一个序列号n在视图v，然后转述一个信息<<ORDER-REQ, v, n, h<sub>n</sub>, d, ND><sub>σ<sub>p</sub></sub>, m>给副本们。v是一个信息已经被发送的视图，n是m被提议的序列号，d = H(m)是m的摘要，h<sub>n</sub> = H(h<sub>n-1</sub>,d)是总结了历史的摘要，ND是在执行过程中需要的不确定的应用变量的值的集合。  
此外，主节点只取t>t<sub>c</sub>的，t<sub>c</sub>是之前从c收到的最高的时间戳。

 > 这里的主节点作恶？  
 答:主节点作恶可能有几种行为。  
 一，主节点不发送ORDER-REQ消息。那么客户端的“第二个计时器”就会到时，客户端重发REQUEST消息给所有副本，副本接收到有效REQUEST消息会给主节点发送CONFIRM-REQ消息并启动一个计时器，主节点在计时器到时前给副本返回ORDER-REQ消息，就又回到了这一阶段。  
 二，主节点发送错误ORDER-REQ消息，ORDER-REQ包含<<ORDER-REQ, v, n, h<sub>n</sub>, d, ND><sub>σ<sub>p</sub></sub>, m>，首先，视图v应该是不容易作假的。至于序列号n，如果副本接受到的ORDER-REQ消息中的n <= max<sub>n</sub>，也就是主节点发送的序列号在副本中已经过时了，那么副本会直接丢弃主节点的ORDER-REQ消息，如果主节点发送的n > max<sub>n</sub>+1，那么说明副本的历史中可能有“空洞”，即副本缺少max<sub>n</sub>到n这段之间的历史，可能是主节点故意发送不好的n导致，也可能是副本之前信息丢失导致。为了弥补这段历史，副本就要发送FILL-HOLE消息给主节点，主节点发送ORDER-REQ消息帮助副本弥补历史空洞，如果主节点没有回应ORDER-REQ消息，那么这个节点就把FILL-HOLE消息发送给其他所有副本，这些副本也可以发送ORDER-REQ消息帮助这个节点弥补历史空洞，如果这些节点也没能返回有效的ORDER-REQ，那么这个节点就开启一个视图变化。  
 当然，主节点还可能篡改消息m，

### 3. 副本们接收有序请求，推测性的执行它，然后回复给客户端
副本从主节点接收了<<ORDER-REQ, v, n, h<sub>n</sub>, d, ND><sub>σ<sub>p</sub></sub>, m>后，检查m是否是一个形态完整良好的REQUEST信息，d是否是m正确的摘要，n = max<sub>n</sub> + 1，max<sub>n</sub>是i的历史中最大的序列号，h<sub>n</sub> = H(h<sub>n-1</sub>,d)，然后才会接受这个有序请求。一旦接受了消息，i将有序请求添加到它的历史中去，在当前的应用状态上执行请求并生成回复r，然后给c发送一个消息<<SPEC-RESPONSE, v, n, h<sub>n</sub>, H(r), c, t><sub>σ<sub>i</sub></sub>, i, r, OR>,OR = <ORDERER-REQ, v, n, h<sub>n</sub>, d, ND><sub>σ<sub>p</sub></sub>。  

  > 这里接收副本作恶?  


一个副本可能在序列号顺序下只收到且预测性的执行了请求，但信息丢失了，或者一个错误主节点会在序列号位置中加入空洞。如果 n <= max<sub>n</sub>，副本 i 丢弃ORDER-REQ信息。如果 n > max<sub>n</sub> + 1，那么 i 丢弃这条信息，并发送一个信息<FILL-HOLE, v, max<sub>n+1</sub>, n, i><sub>σ<sub>i</sub></sub>给主节点，并开启一个计时器。一旦从副本 i 收到消息<FILL-HOLE, v, max<sub>n</sub>+1, n, i><sub>σ<sub>i</sub></sub>，主节点 p 发送一个<<ORDER-REQ, v, n', h<sub>n'</sub>, d, ND><sub>σ<sub>p</sub></sub>, m'>给 i , p 将每个请求 m' 排序在 k <= n' <= n 在当前视图中；主节点忽视来自其他视图的fill-hole请求。如果 i 收到了有效的ORDER-REQ信息填了这个洞，那么它就取消计时器。否则副本就广播FILL-HOLE信息给其他所有的副本，当计时器触发时，开始一个视图变化。任意副本 j 收到一个来自 i 的FILL-HOLE 信息就发送一个相对应的ORDER-REQ信息。如果副本在处理填补空洞时，副本 i 收到了矛盾的ORDER-REQ信息，这些矛盾的信息就形成一个不良行为的证明，在 4d 中描述。
### 4. 客户端收集预测性回复
客户端从副本收到信息<<SPEC-RESPONSE, v, n, h<sub>n</sub>, H(r), c, t><sub>σ<sub>i</sub></sub>, i, r, OR>，i 证明了副本发布了回复。如果来自不同副本的SPEC-RESPONSE信息中的v,n,h<sub>n</sub>,H(r),c,t和r这些域的值都完全一致时，那么这些SPEC-RESPONSE _匹配 match_ 。有四种情况需要考虑，前三种由收到的匹配的预测性回复的数量区别，而不考虑OR域，最后一种只考虑OR域。
#### 4a. 客户端收到 3f + 1 个匹配的回复并完成了请求
在错误存在的情况下，客户端从所有3f+1个副本收到了匹配的SPEC-RESPONSE消息。客户端接着就认为请求和它的历史 _完成 complete_ ，**并发送回复 r 给应用** 。Zyzzyva 保证了即使有视图变化，所有的副本一定会执行请求在他们的历史上生成回复。注意到客户端有一个证明，证明那些请求在历史中是不可取消的，但没有服务端有这样的证明。就是说，服务端此时不能确定这个请求是否完成了，也不确定一个服务状态的回滚是否必须的，因为一个错误的主节点排序了和其他副本不一致的请求。
#### 4b. 客户端收到介于 2f + 1 和 3f 之间的匹配的回复，装配一个提交证书，然后把提交证书转发给所有副本们
如果网络、主节点或者一些副本错误，那么客户端c可能永远收不到 3f + 1 个副本的回复。因此客户端第一次发起请求时就设置一个计时器，当计时器到期限时，如果c收到了介于 2f + 1 和 3f 之间个副本的匹配的推测性回复，c就发出一个消息<COMMIT, c, CC><sub>σ<sub>c</sub></sub>，CC是一个由 2f + 1 个副本列表组成的提交证书，副本签署了 2f + 1 个匹配的SPEC-RESPONSE消息，以及对应的 2f + 1 个副本的签名。  
CC包含了 2f + 1 个签名的SPEC-PESPONSE消息和一份2f + 1 个节点的列表。但是，由于由c收到的所有副本的回复都是一致的，所以，c只需要包含一个副本签名的SPEC-ERSPONSE消息。为了效率，CC并不包含回复的整体部分 r ，而是只有 H(r)。
##### 4b.1. 副本从客户端收到一个包含了提交证书的 COMMIT 消息，回复一个 LOCAL-COMMIT 消息
当一个副本 i 收到一个消息<COMMIT, c, CC><sub>σ<sub>c</sub></sub>中包含了一个有效的提交证书CC,CC证明了在当前视图中一个有特定序列号和历史的请求应该被执行，副本首先确认本地历史和CC中证实的历史是一致的。如果是，那么副本 i (1)假如这个证书的序列号比存储的证书的序列号高，更新他的 _max commit certificate_ 状态。(2)发送一个消息<LOCAL-COMMIT, v, d, h, i, c><sub>σ<sub>i</sub></sub>给 c 。  
如果当地历史对于CC的历史是有漏洞的，那么 i 就像3中描述的那样填补他们。然而如果两个历史对于不同的请求有相同的序列号，那么 i 开始视图变化协议。
##### 4b.2. 客户从 2f + 1 个副本收到LOCAL-COMMIT消息，请求完成
客户端发送COMMIT消息，直到从 2f + 1 个不同的副本收到LOCAL-COMMIT消息。客户端就认为请求和它的历史 _完成 complete_ 并发送回复 r 给应用。系统保证即使有一个视图改变，所有的副本仍然会执行这个请求在他们的历史中，生成这个回复。  
当客户端第一次发送COMMIT消息给副本时它开始一个计时器。如果在收到 2f + 1 个LOCAL-COMMIT之前计时器到时了，那么客户端就转为接下来4c介绍的协议。
#### 4c. 客户端收到不到 2f + 1 个匹配的 SPEC-REESPONSE 消息，重发它的请求给所有副本，通过发送请求给主节点，为了确保请求被安排一个序列号并被最终执行
**客户端.**如果网络的主节点有错误，客户端 c 可能永远不能从 2f + 1 个副本收到匹配的SPEC-RESPONSE消息。客户端在第一次发送请求时会设置第二个计时器，在计时器到时时重发REQUEST消息给所有副本。接着它重置它的计时器们并接着收集推测性回复。  
**副本.**当非主节点副本 i 从一个客户端c收到一个消息<REQUEST, o, t, c><sub>σ<sub>c</sub></sub>, i 可能会采取两种行为。如果该请求匹配或者有一个比当前缓存请求更低的客户提供的时间戳同样来自c，i 重发缓存的回复给 c 。如果请求有一个更高的时间戳高于当前缓存回复，i 发送一个消息<CONFIRM-REQ, v, m, i><sub>σ<sub>i</sub></sub>给主节点 p 并开始一个计时器, m = <REQUEST, o, t, c><sub>σ<sub>c</sub></sub>。如果副本接受了一个对于这个请求的ORDER-REQ消息在计时器结束之前，他就像上述一样处理ORDER-REQ消息。如果计时器在主节点给请求排序之前触发，副本就开始一个视图变化。  
**主节点.**一但从副本 i 接受确认请求消息<CONFIRM-REQ, v, m, i><sub>σ<sub>i</sub></sub>,主节点 p 检查请求中的客户端时间戳。如果请求是新的，p 发送一个新的ORDER-REQ消息，这个消息使用下一个序列号来排序就像在第2步中说的一样；否则，p 发送给 i 缓存的ORDER-REQ消息，这是一个从 c 来的最近的请求。  
如果副本 i 收到一个提交证书或者稳定的检查点关于一个随后的请求，副本就发送一个LOCAL-COMMIT给客户端，即使客户端没有收到一个提交证书对于一个重传的请求。如果副本 i 没有收到主节点的ORDER-REQ消息，副本就发送CONFIRM-REQ消息给所有的其他副本。一旦接受到来自其他副本 j 的CONFIRM-REQ消息，副本 i 发送它收到的主节点的一个ORDER-REQ消息给 j ；如果 i 没有收到来自客户端的请求，i 假装请求是来自客户端本端的。
#### 4d. 客户端收到一个请求暗示了主节点排序的不一致性，就发送一个不良行为的证明给副本们，这会开始一个视图变化取代主节点
如果客户端收到两个SPEC-RESPONSE消息包含了有效的 OR = <ORDERER-REQ, v, n, h<sub>n</sub>, d, ND><sub>σ<sub>p</sub></sub>对于一个请求(d = H(m))在一个视图v中，但有着不同的序列号n或历史h<sub>n</sub>，那么这一对ORDER-REQ消息就组成一个不良行为证明(POM)，针对于主节点。一旦收到POM，c 发送一个消息<POM, v, **POM** ><sub>σ<sub>c</sub></sub>给所有的副本。 一点收到有效的POM消息，一个副本会开启一个视图变化并发送POM消息给其他副本。  
4b和4c和4d不冲突；一个客户端可能会收到足够的消息完成一个请求或者生成一个提交证书并且主节点行为不良证明。  









---
**REFERENCES**

[1] Kotla, Ramakrishna . "Zyzzyva: speculative byzantine fault tolerance." Acm Sigops Symposium on Operating Systems Principles ACM, 2007.


