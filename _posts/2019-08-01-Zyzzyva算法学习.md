---
title: Zyzzyva算法学习
date: 2019-08-01 10:52:30
categories:
- zyzzyva
tags: 
- zyzzyva
---

Zyzzyva算法，在状态机复制中的一个重要的算法，现总结其过程如下。  
Zyzzyva在3f+1个副本replicas之间执行

  > 问题1:为什么一定要3f+1?

首先，客户端client想要执行一个请求,所以客户端发送一个 _request_ 给主节点primary。
  
  > 问题2:为什么不直接发送给所有副本?  

主节点将请求发给其他所有副本，副本执行请求并将它们的回复 _responses_ 发给客户端。
  
  > 问题3:为什么不发回给主节点?

这时，一个请求可能在此完成，这里是请求完成的第一个方式，就是如果客户端收到3f+1个一致的回复(包含应用层面的 _reply_ 和 _history_ )。这时客户端认为请求完成。
  
  > 问题4:为什么此时认为请求完成?

第二种完成方式，如果客户端收到2f+1到3f之间的一致的回复，这时客户端将2f+1个回复打包并分发这个 _提交证书 commit certificate_ 给所有副本。
  
  > 问题5:为什么是2f+1个证书?  
    问题6:为什么要发给所有副本?

一旦有2f+1个副本承认收到了提交证书，那么客户端就认为请求完成了。

  > 问题7:为什么这里可以认为请求完成了？

如果有充足数量的副本认为当前的主节点是有错误的(拜占庭节点)，那么会有一个 _视图改变 view change_ 发生，一个新的主节点就会被选出。以上就是zyzzyva的主要过程。  

接着讨论副本的问题。每个副本 _i_ 中保存着一个有序的 _历史 histroy_，历史中包含了该副本所有执行过的请求，副本中还有一个 _max commit certificate_ 的拷贝。

  > 问题8:max commit certificate的作用?

__这个提交证书包含了i存储的历史的最大的前缀。__ 被提交证书覆盖到的历史是 _已提交历史 committed history_ ,这以后的历史是 _推测历史 speculative history_ 。如果n是已提交历史中的最大序列号，我们说一个提交证书具有序列号n。
每次有 CP_INTERVAL 请求时，副本构建一个检查点。每个副本保存有一个 _稳定检查点 stable checkpoint_ ,还可能保存了一个 _实验性检查点 tentative checkpoing_ 和一个对应的 _实验性应用状态快照 tentative application state snapshot_ 。实验性检查点和应用状态成为已提交的的过程和之前的BFT协议很相似，后续再讨论这一点。  
简单来说，当一个正确的副本生成一个实验性检查点，他发送一个标记为 CHECKPOINT 的信息给所有的副本。信息中包含了这个检查点中包含的最高的序列号和一个实验性检查点和应用状态快照的摘要。一个正确的Zyzzyva副本收集了f+1个匹配的被不同副本签名的CHECKPOINT信息后，就会认为这个检查点和对应的应用快照是稳定的。  
为了限制历史的大小，一个副本采用两个方法，(1)缩短已提交检查点之前的历史，(2)从上次已提交检查点之后处理 2\*CP_INTERVAL 个请求后阻塞新请求的处理。
最后，每个副本保存一个 _回复缓存 response cache_，其中包含了最新的有序的请求来自的客户端，和相应的回复到的地方。  
接着，对之前的过程进行详细说明。
#### 1. 用户发送请求给主节点
一个客户端c请求一个操作o被复制的服务实行，就发送一个信息<REQUEST, o, t, c><sub>σ<sub>c</sub></sub>给一个客户端认为是主节点的(这个客户端最后一次收到回复的主节点)。  
如果客户端猜错了主节点，重传机制会将请求发送给当前主节点。客户端的时间戳t确保请求只被执行一次。
#### 2. 主节点接收请求，分配序列号，将有序请求发送给副本们  
当主节点p从客户端c收到消息<REQUEST, o, t, c><sub>σ<sub>c</sub></sub>,主节点p分配一个序列号n在视图v，然后转述一个信息<<ORDER-REQ, v, n, h<sub>n</sub>, d, ND><sub>σ<sub>p</sub></sub>, m>给副本们。v是一个信息已经被发送的视图，n是m被提议的序列号，d = H(m)是m的摘要，h<sub>n</sub> = H(h<sub>n-1</sub>,d)是总结了历史的摘要，ND是在执行过程中需要的不确定的应用变量的值的集合。  
此外，主节点只取t>t<sub>c</sub>的，t<sub>c</sub>是之前从c收到的最高的时间戳。
#### 3. 副本们接收有序请求，推测性的执行它，然后回复给客户端
副本从主节点接收了<<ORDER-REQ, v, n, h<sub>n</sub>, d, ND><sub>σ<sub>p</sub></sub>, m>后，检查m是否是一个形态完整良好的REQUEST信息，d是否是m正确的摘要，n = max<sub>n</sub> + 1，max<sub>n</sub>是i的历史中最大的序列号，h<sub>n</sub> = H(h<sub>n-1</sub>,d)，然后才会接受这个有序请求。一旦接受了消息，i将有序请求添加到它的历史中去，在当前的应用状态上执行请求并生成回复r，然后给c发送一个消息<<SPEC-RESPONSE, v, n, h<sub>n</sub>, H(r), c, t><sub>σ<sub>i</sub></sub>, i, r, OR>,OR = <ORDERER-REQ, v, n, h<sub>n</sub>, d, ND><sub>σ<sub>p</sub></sub>。  
一个副本可能在序列号顺序下只收到且预测性的执行了请求，但信息丢失了，或者一个错误主节点会在序列号位置中加入破洞。如果 n <= max<sub>n</sub>，副本 i 丢弃ORDER-REQ信息。如果 n > max<sub>n</sub> + 1，那么 i 丢弃这条信息，发送一个信息<FILL-HOLE, v, max<sub>n+1</sub>, n, i><sub>σ<sub>i</sub></sub>给主节点，并开启一个计时器。一旦从副本 i 收到消息<FILL-HOLE, v, max<sub>n+1, n, i><sub>σ<sub>i</sub></sub>，主节点 p 发送一个<<ORDER-REQ, v, n', h<sub>n'</sub>, d, ND><sub>σ<sub>p</sub></sub>, m'>给 i , p 将每个请求 m' 排序在 k <= n' <= n 在当前视图中；主节点忽视来自其他视图的fill-hole请求。如果 i 收到了有效的ORDER-REQ信息填了这个洞，那么它就取消计时器。否则副本就广播FILL-HOLE信息给其他所有的副本并开始一个视图变化，计时器计数结束时也是这样。任意副本 j 收到一个来自 i 的FILL-HOLE 信息就发送一个相对应的ORDER-REQ信息。如果副本在处理填补破洞时，副本 i 收到了矛盾的ORDER-REQ信息，这些矛盾的信息就形成一个不良行为的证明，在 4d 中描述。
#### 4. 客户端收集预测性回复
客户端从副本收到信息<<SPEC-RESPONSE, v, n, h<sub>n</sub>, H(r), c, t><sub>σ<sub>i</sub></sub>, i, r, OR>，i 证明了副本发布了回复。如果来自不同副本的SPEC-RESPONSE信息中的v,n,h<sub>n</sub>,H(r),c,t和r这些域的值都完全一致时，那么这些SPEC-RESPONSE _匹配 match_ 。有四种情况需要考虑，前三种又收到的匹配的预测性回复的数量区别，而不考虑OR域，最后一种只考虑OR域。
###### 4a. 客户端收到 3f + 1 个匹配的回复并完成了请求







---
[1] Kotla, Ramakrishna . "Zyzzyva: speculative byzantine fault tolerance." Acm Sigops Symposium on Operating Systems Principles ACM, 2007.


